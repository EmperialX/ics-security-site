<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Obfuscation Challenge Presentation</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="ics-theme.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <div class="presentation-container">
        <div class="controls">
            <button id="prev" class="nav-btn"><i class="fas fa-chevron-left"></i></button>
            <div class="progress-container">
                <div class="progress-bar"></div>
            </div>
            <button id="next" class="nav-btn"><i class="fas fa-chevron-right"></i></button>
        </div>

        <div class="slide active" id="title-slide">
            <div class="slide-content">
                <div class="title-content">
                    <div class="title-icon">
                        <i class="fas fa-shield-alt"></i>
                    </div>
                    <h1>Advanced Binary Obfuscation</h1>
                    <p class="subtitle">BinaryClash 360 Hackathon - Defense & Attack Phases</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-bullseye"></i> Challenge Overview</h2>
                <div class="content-box">
                    <p>The BinaryClash 360 Hackathon consisted of two phases:</p>
                    <ul>
                        <li><strong>Defense Phase:</strong> Create heavily obfuscated AES implementation that protects sensitive data</li>
                        <li><strong>Attack Phase:</strong> Reverse engineer opponents' obfuscated binaries</li>
                    </ul>
                    <p>Key objectives:</p>
                    <ul>
                        <li>Protect three sensitive components: eggs, global flag, and key</li>
                        <li>Maintain functional correctness of the implementation</li>
                        <li>Defeat common reverse engineering techniques</li>
                        <li>Complete both defense and attack within time constraints</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-lock"></i> Obfuscation Strategy</h2>
                <div class="content-box">
                    <p>Our multi-layered defense combined source-level and binary-level techniques:</p>
                    <ol>
                        <li><strong>Mathematical transformation of constants</strong>: Transform all sensitive values at compile time</li>
                        <li><strong>Control flow obfuscation</strong>: Disrupt program flow using opaque predicates</li>
                        <li><strong>Anti-analysis techniques</strong>: Deploy anti-debugging, anti-VM, and anti-emulation</li>
                        <li><strong>Runtime code encryption</strong>: Selectively encrypt non-critical code regions</li>
                        <li><strong>String encryption</strong>: XOR-based encryption of non-essential strings</li>
                        <li><strong>Self-modifying code</strong>: Enable runtime code modifications</li>
                        <li><strong>Advanced polymorphic techniques</strong>: NTCrypt-inspired dynamic key evolution</li>
                    </ol>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-key"></i> Key Transformation</h2>
                <div class="content-box">
                    <p>The AES key was obfuscated using multiple transformations:</p>
                    <div class="code-snippet">
<pre>// Original key
uint8_t key[AES_BLOCKLEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// Transformed key
uint8_t key[AES_BLOCKLEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};</pre>
                    </div>
                    <p>Three different transformations were used:</p>
                    <ul>
                        <li><strong>XOR transformation</strong>: <code>key[i] = original_key[i] ^ random_value</code></li>
                        <li><strong>Addition transformation</strong>: <code>key[i] = (original_key[i] + random_value) % 256</code></li>
                        <li><strong>Bit rotation</strong>: <code>key[i] = ((original_key[i] << rotation) | (original_key[i] >> (8 - rotation))) & 0xFF</code></li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-random"></i> Control Flow Obfuscation</h2>
                <div class="content-box">
                    <p>We implemented advanced control flow obfuscation using opaque predicates and complex conditional expressions:</p>
                    <div class="code-snippet">
<pre>volatile int p = (round * 0x1337) & 0xFF;
volatile int q = ((p << 3) ^ (p >> 5)) & 0xFF;
volatile int r = ((q * 7) + (p ^ 0x42)) & 0xFF;

if (OBFUSCATE_CONTROL_FLOW(q != (p ^ 0xA5) || (r & 0x28) != 0x28)) {
    goto label_true;
}</pre>
                    </div>
                    <p>The OBFUSCATE_CONTROL_FLOW macro further complicates analysis:</p>
                    <div class="code-snippet">
<pre>#define OBFUSCATE_CONTROL_FLOW(cond) ({ \
    unsigned int __rdtsc_val = 0; \
    __asm__ volatile ("rdtsc" : "=a" (__rdtsc_val)); \
    (((cond) ^ (((uintptr_t)&&label_true >> 4) & 0x1)) && ((__rdtsc_val & 0x400) == 0)); \
})</pre>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-flag"></i> Global Flag Obfuscation</h2>
                <div class="content-box">
                    <p>The global flag was obfuscated with mathematical identities:</p>
                    <div class="code-snippet">
<pre>// Original
uint8_t global_flag = 0;

// Obfuscated initialization
uint8_t global_flag = 0x00 ^ 0x00; // Mathematical identity that equals 0</pre>
                    </div>
                    <p>We implemented a polymorphic reconstruction function that always returns zero through different execution paths:</p>
                    <div class="code-snippet">
<pre>static inline uint8_t reconstruct_global_flag(uint8_t seed) {
    uint64_t timestamp;
    __asm__ volatile("rdtsc" : "=A" (timestamp));
    uint8_t path = (timestamp & 0x3) + (seed & 0x3);
    uint8_t result = 0;
    
    switch(path % 4) {
        case 0:
            result = ((seed | 0x00) & 0x00) ^ ((seed | 0x00) & 0x00);
            break;
        case 1:
            for (int i = 0; i < 8; i++) {
                result |= (((seed >> i) & 1) ^ ((seed >> (7-i)) & 1)) << i;
            }
            break;
        case 2:
            result = (seed * 2) & (~seed) & 0xFF;
            result ^= result;
            break;
        case 3:
            result = ((seed + 0x00) ^ 0x00) & ((~seed + 1) ^ (~seed + 1));
            break;
    }
    return result;
}</pre>
                    </div>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-code"></i> Binary-Level Transformations</h2>
                <div class="content-box">
                    <p>We implemented NTCrypt-inspired binary transformations:</p>
                    <ol>
                        <li><strong>Selective Code Encryption:</strong>
                            <div class="code-snippet">
<pre>section_key = hashlib.sha256((section.name + str(offset) + binary_id).encode()).digest()[:16]
for i in range(offset, end):
    data[i] ^= section_key[i % len(section_key)]</pre>
                            </div>
                        </li>
                        <li><strong>String Encryption:</strong>
                            <div class="code-snippet">
<pre>xor_key = 0x42
for i in range(pos, end):
    content[i] ^= xor_key</pre>
                            </div>
                        </li>
                        <li><strong>Self-Modifying Code Support:</strong>
                            <div class="code-snippet">
<pre>static inline void modify_code(uint8_t* code_ptr, size_t len, uint8_t key) {
    make_memory_writable(code_ptr, len);
    for (size_t i = 0; i < len; i++) {
        code_ptr[i] ^= key;
    }
    __builtin___clear_cache((char*)code_ptr, (char*)(code_ptr + len));
}</pre>
                            </div>
                        </li>
                    </ol>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-project-diagram"></i> Obfuscation Pipeline</h2>
                <div class="content-box">
                    <div class="two-columns">
                        <div class="column">
                            <h3>First Stage: Source-Level</h3>
                            <ul>
                                <li><strong>preprocess.py:</strong> 
                                    <ul>
                                        <li>Obfuscates the AES key</li>
                                        <li>Preserves egg_params array</li>
                                        <li>Obfuscates global_flag</li>
                                        <li>Adds control flow obfuscation</li>
                                    </ul>
                                </li>
                                <li><strong>Header Files:</strong>
                                    <ul>
                                        <li>obfuscator.h: Anti-analysis techniques</li>
                                        <li>metamorphic.h: Polymorphic code</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <div class="column">
                            <h3>Second Stage: Binary</h3>
                            <ul>
                                <li><strong>Compilation:</strong>
                                    <ul>
                                        <li>-fPIC -O1</li>
                                        <li>-fno-stack-protector</li>
                                        <li>-fomit-frame-pointer</li>
                                        <li>-static-pie</li>
                                    </ul>
                                </li>
                                <li><strong>binary_transform.py:</strong>
                                    <ul>
                                        <li>Adds encrypted sections</li>
                                        <li>Implements string encryption</li>
                                        <li>Enables self-modifying code</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-bug"></i> Security Analysis</h2>
                <div class="content-box">
                    <div class="two-columns">
                        <div class="column">
                            <h3>Static Analysis Resistance</h3>
                            <ul>
                                <li><strong>Control Flow Complexity:</strong> Information-theoretic lower bound of log₂(n!) bits</li>
                                <li><strong>Opaque Predicates:</strong> Hardware-dependent conditions (RDTSC)</li>
                                <li><strong>Constant Obfuscation:</strong> No original values in binary</li>
                            </ul>
                        </div>
                        <div class="column">
                            <h3>Dynamic Analysis Resistance</h3>
                            <ul>
                                <li><strong>Anti-Debugging:</strong> Multiple layers of detection</li>
                                <li><strong>Self-Modifying Code:</strong> Runtime code changes</li>
                                <li><strong>Polymorphic Execution:</strong> Multiple runtime paths</li>
                            </ul>
                        </div>
                    </div>
                    <div class="security-equation">
                        <p><strong>Mathematical Security Guarantees:</strong></p>
                        <ul>
                            <li><strong>Key Transformation:</strong> 2^128 theoretical security</li>
                            <li><strong>Control Flow Obfuscation:</strong> ~60 bits of security (log₂(20!))</li>
                            <li><strong>Statistical Analysis Resistance:</strong> Dynamic key evolution</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-search"></i> Attacking Phase: Reverse Engineering</h2>
                <div class="content-box">
                    <p>When faced with an opponent's obfuscated binary, we started our analysis:</p>
                    <ol>
                        <li><strong>Initial Reconnaissance:</strong> Examining decompiled code for AES patterns</li>
                        <li><strong>Locating Key Data:</strong> Found references to egg parameters and global flag</li>
                        <li><strong>Finding the S-box:</strong> Searched for the standard AES S-box pattern</li>
                        <li><strong>Setting Strategic Breakpoints:</strong> Before and after key operations</li>
                    </ol>
                    <div class="code-snippet">
<pre>// Located pattern in memory:
0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0</pre>
                    </div>
                    <p class="definition">Key Memory Addresses Identified: 0x47a0a0 (AES S-box), 0x4b6311 (Egg 0), 0x4b6316 (Global Flag)</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-tools"></i> Dynamic Analysis Approach</h2>
                <div class="content-box">
                    <p>Our dynamic analysis involved several key steps:</p>
                    <ol>
                        <li><strong>Function Identification:</strong> Located key functions in the execution flow</li>
                        <li>
                            <strong>Critical Functions Found:</strong>
                            <ul>
                                <li><code>FUN_004025ed</code> - Key expansion function</li>
                                <li><code>FUN_00401d9a</code> - Setup for encryption</li>
                                <li><code>FUN_00402f32</code> - Main AES cipher function</li>
                            </ul>
                        </li>
                        <li><strong>Memory Examination:</strong> Set breakpoints and examined key memory regions</li>
                        <li><strong>String Analysis:</strong> Found format strings like "Ciphertext:" and "Egg 0 : 0x%"</li>
                        <li><strong>Hardware Breakpoints:</strong> Set on critical memory addresses to track changes</li>
                    </ol>
                    <div class="code-snippet">
<pre>gdb_command('break *0x401750')  // Entry point breakpoint
gdb_command('x/32xb 0x47a0a0')  // Examine memory at S-box location
gdb_command('watch *0x4b6311')  // Watch for changes to Egg 0</pre>
                    </div>
                </div>
            </div>
        </div>

        
        <div class="slide">
            <div class="slide-content">
                <h2><i class="fas fa-lightbulb"></i> Lessons Learned</h2>
                <div class="content-box">
                    <blockquote>
                        <strong>Binary obfuscation is an arms race:</strong> Every defensive measure has a potential counteroffensive, and the most effective protection comes from layering multiple techniques.
                    </blockquote>
                    <h3>Key Takeaways:</h3>
                    <ul>
                        <li><strong>Multiple Protection Layers:</strong> No single technique is sufficient</li>
                        <li><strong>Deeper ≠ Better:</strong> Sometimes simple but unexpected techniques work best</li>
                        <li><strong>Balance:</strong> Overly complex obfuscation can hint at what's important</li>
                        <li><strong>Anti-analysis:</strong> Detecting and responding to analysis tools is critical</li>
                        <li><strong>Error Handling:</strong> How a program fails can leak information</li>
                        <li><strong>Recognizable Patterns:</strong> The AES S-box is a clear signature</li>
                    </ul>
                    <p>Practical skills in both creating and defeating obfuscation are valuable in security, malware analysis, and software protection domains.</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="slide-content">
                <div class="title-content">
                    <h1>Thank You</h1>
                    <p class="subtitle">Questions?</p>
                    <div class="title-icon">
                        <i class="fas fa-question-circle"></i>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html>
